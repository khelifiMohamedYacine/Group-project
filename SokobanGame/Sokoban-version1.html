<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Skoban Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        body {
            background-size: 100%;
            background-position: left;
            background-repeat: repeat-y;
            background-color: #708090;
        }

        #yxbox {
            padding: 0;
            margin: 0 auto;
            margin-top: 128px;
            list-style: none;
            position: relative;

        }

        #yxbox li {
            width: 128px;
            height: 128px;
            float: left;
        }

        #yxbox .pos0 {
            background: url('img/wall2.png') no-repeat;
            z-index: 1;
        }

        #yxbox .pos1 {
            background: url('img/wall.png') no-repeat;
            z-index: 1;
        }

        #yxbox .pos2 {
            background: url('img/ground.png') no-repeat;
            z-index: 1;
        }

        #yxbox .pos3 {
            background: url('img/target2.png') no-repeat;
            z-index: 999;
        }

        #yxbox .person1, #yxbox .person2, #yxbox .person3, #yxbox .person4 {
            width: 128px;
            height: 128px;
            position: absolute;
            background-image: url('img/person2.png');
            background-repeat: no-repeat;
            z-index: 9999;
        }

        #yxbox .box {
            width: 128px;
            height: 128px;
            position: absolute;
            background-image: url('img/box2.png');
            background-repeat: no-repeat;
            z-index: 9999;
        }

        #yxbox .person1 {
            background-position: 0;
        }

        #yxbox .person2 {
            background-position: -128px 0;
        }

        #yxbox .person3 {
            background-position: -256px 0;
        }

        #yxbox .person4 {
            background-position: -384px 0;
        }

        #yxbox .box.onTarget {
            background-image: url('img/onTarget2.png');
        }

    </style>
</head>
<body>
<ul id="yxbox">

</ul>


<script>
    class Sokoban {
        constructor(gameBoard) {
            this.gameBoard = gameBoard;
            this.levels = [];
            this.currentLevel = 0;
            this.player = null;
            this.boxes = [];
            this.targets = {};
            this.history = [];

            // Sound effects
            this.sounds = {
                bgm: new Audio("mp3/background.mp3"), // Background music
                push: new Audio("mp3/moveBox.wav"), // Pushing box sound
                place: new Audio("mp3/target.wav"), // Box placed on target sound
            };

            // Set background music to loop
            this.sounds.bgm.loop = true;
            this.sounds.bgm.volume = 0.1;
        }

        //  Play sound effects
        playSound(sound) {
            if (this.sounds[sound]) {
                this.sounds[sound].currentTime = 0;
                this.sounds[sound].play();
            }
        }

        // ðŸŽµ Start background music
        startBGM() {
            this.sounds.bgm.play();
        }

        // Load level data from external JSON
        async loadLevels() {
            try {
                const response = await fetch('levels.json'); // Fetch external JSON file
                this.levels = await response.json();
                this.initLevel(this.currentLevel);
            } catch (error) {
                console.error('Failed to load level data:', error);
            }
        }

        // Initialize level
        initLevel(levelIndex) {
            this.startBGM();
            this.gameBoard.innerHTML = "";
            this.history = [];
            this.targets = {};
            this.boxes = [];
            this.steps = 0; // Reset step count

            const level = this.levels[levelIndex];
            document.title = `Current Level: ${levelIndex + 1}`;

            const gridSize = Math.sqrt(level.map.length);
            this.gameBoard.style.width = `${gridSize * 128}px`;

            // Render map
            level.map.forEach((tile, index) => {
                const tileElement = document.createElement('li');
                tileElement.className = `pos${tile}`;
                this.gameBoard.appendChild(tileElement);

                // Store target positions
                if (tile === 3) {
                    this.targets[tileElement.offsetLeft + '_' + tileElement.offsetTop] = true;
                }
            });

            // Render player
            this.createPlayer(level.personPos);

            // Render boxes
            level.boxPos.forEach(pos => this.createBox(pos));
        }

        // Create player character
        createPlayer(position) {
            this.player = document.createElement('div');
            this.player.className = 'person1';
            this.player.x = position.x;
            this.player.y = position.y;
            this.updatePosition(this.player);
            this.gameBoard.appendChild(this.player);
        }

        // Create boxes
        createBox(position) {
            const box = document.createElement('div');
            box.className = 'box';
            box.x = position.x;
            box.y = position.y;
            this.updatePosition(box);
            this.boxes.push(box);
            this.gameBoard.appendChild(box);
            this.updateBoxState();
        }

        // Update object position
        updatePosition(obj) {
            obj.style.left = `${obj.x * 128}px`;
            obj.style.top = `${obj.y * 128}px`;
        }

        // Update box state and play sound effects
        updateBoxState() {
            this.boxes.forEach(box => {
                const boxPositionKey = box.offsetLeft + "_" + box.offsetTop;
                const wasOnTarget = box.classList.contains('onTarget'); // Was it on target before?

                if (this.targets[boxPositionKey]) {
                    box.classList.add('onTarget');
                    if (!wasOnTarget) this.playSound("place"); // Play sound only if newly placed
                } else {
                    box.classList.remove('onTarget');
                }
            });
        }

        // Handle player movement and direction
        movePlayer(direction) {
            this.steps++;
            console.log("Steps:", this.steps);

            const nextX = this.player.x + direction.x;
            const nextY = this.player.y + direction.y;
            const pushX = nextX + direction.x;
            const pushY = nextY + direction.y;

            const level = this.levels[this.currentLevel];
            const gridSize = Math.sqrt(level.map.length);
            if (level.map[nextY * gridSize + nextX] === 1) return;

            // Update player direction
            this.updatePlayerDirection(direction);

            // Check if a box is present
            const box = this.boxes.find(b => b.x === nextX && b.y === nextY);
            if (box) {
                this.playSound("push"); // Play pushing sound effect
                const nextTile = level.map[pushY * gridSize + pushX];

                // If the box is blocked, do not move it
                if (nextTile === 1 || this.boxes.some(b => b.x === pushX && b.y === pushY)) return;

                // Move box
                box.x = pushX;
                box.y = pushY;
                this.updatePosition(box);
                this.updateBoxState();
            }

            // Move player
            this.player.x = nextX;
            this.player.y = nextY;
            this.updatePosition(this.player);

            // Record move history
            this.history.push({
                playerPos: { x: this.player.x, y: this.player.y },
                boxes: this.boxes.map(b => ({ x: b.x, y: b.y }))
            });

            // Check if level is completed
            if (this.boxes.every(function (box) {
                return this.targets[box.offsetLeft + "_" + box.offsetTop];
            }, this)) {
                alert('Level Complete!');
                this.nextLevel();
            }
        }

        // Update player direction
        updatePlayerDirection(direction) {
            if (direction.x === -1) {
                this.player.style.backgroundPosition = "-128px 0"; // Left
            } else if (direction.x === 1) {
                this.player.style.backgroundPosition = "-384px 0"; // Right
            } else if (direction.y === -1) {
                this.player.style.backgroundPosition = "0 0"; // Up
            } else if (direction.y === 1) {
                this.player.style.backgroundPosition = "-256px 0"; // Down
            }
        }

        // Move to next level
        nextLevel() {
            this.currentLevel++;
            if (this.currentLevel < this.levels.length) {
                this.initLevel(this.currentLevel);
            } else {
                alert('Congratulations! You completed all levels.');
            }
        }

        // Undo last move
        undo() {
            if (this.history.length === 0) return;
            const lastMove = this.history.pop();
            this.player.x = lastMove.playerPos.x;
            this.player.y = lastMove.playerPos.y;
            this.updatePosition(this.player);

            this.boxes.forEach((box, i) => {
                box.x = lastMove.boxes[i].x;
                box.y = lastMove.boxes[i].y;
                this.updatePosition(box);
            });
            this.updateBoxState();
        }

        // Bind keyboard events
        bindEvents() {
            document.addEventListener('keyup', event => {
                const moves = {
                    37: { x: -1, y: 0 }, // Left Arrow
                    38: { x: 0, y: -1 }, // Up Arrow
                    39: { x: 1, y: 0 }, // Right Arrow
                    40: { x: 0, y: 1 }, // Down Arrow
                    90: () => this.undo(), // Z to undo
                };
                if (moves[event.keyCode]) {
                    this.movePlayer(moves[event.keyCode]);
                }
            });
        }
    }

    // Initialize game
    const game = new Sokoban(document.getElementById('yxbox'));
    game.loadLevels();
    game.bindEvents();
</script>


</body>
</html>

